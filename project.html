<!doctype html>
<html>

<head>
    <title>Enter Game Name Here</title>
    <!--Phaser library version: 2.6.2-->
    <script src="lib/phaser.min.js"></script>
	<script src="lib/jquery-3.1.1.min.js"></script>

    <!-- Import all our javascript files here -->
    <script src="js/Click.js"></script>
    <script src="js/LightningSpell.js"></script>
    <script src="js/RandomGeneration.js"></script>


</head>

<body>


    <script type="text/javascript">
//<!--Game code goes here-->


//<!--load before the game-->
function preload()
{
    game.load.spritesheet("test_dude", "assets/placeholder/dude.png", 32, 48);
    game.load.image("test_ground", "assets/placeholder/ground.png");
    game.load.image("fire1", "assets/placeholder/fire1.png");
    game.load.image("fire2", "assets/placeholder/fire2.png");
    game.load.image("fire3", "assets/placeholder/fire3.png");
    
    // this is copied from the tilemap example I found on Phaser.io



}
//<!--End Of preload()-->



//<!--Variables for basic elements in game-->
var current_click = null;       // this is the player's current click. is null when not clicking

var game = new Phaser.Game(1334, 750, Phaser.AUTO, "[INSERT GAME NAME HERE]", { preload: preload, create: create, update: update});
var player;
var platforms;

var platform_scrolling_speed = 300;
var player_can_jump = false;

var lightningSpells = [];
//<!--End of basic elements-->


//<!--Variables for dialogue and displaying-->
var upKey;										//The key for testing text displaying

var dialogue = jQuery.parseJSON(				//All dialogue text is stored in the JSON file
	jQuery.ajax({								//JSON.parse() will parse json before ajac call is finished
		url: "js/dialogue.json",				//and this will error and make the dialogue empty
		async: false,							//This will block the browser until ajax call is finished
		dataType: "json"
	}).responseText
);
//<!--End of dialogue-->

//<!--upon creation of the game-->
function create()
{
	upKey = game.input.keyboard.addKey(Phaser.Keyboard.UP);		//the key for testing dialogue display
	
	//alert(dialogue.crush);

    var i = 0; // this is the loop counter;
    game.physics.startSystem(Phaser.Physics.ARCADE);

    game.input.mouse.capture = true;    // track the mouse
    game.time.advancedTiming = true;    // allow an fps counter without my having to make one

    platforms = game.add.group();
    platforms.enableBody = true;

    var test_ground = platforms.create(0, game.world.height - 64, "test_ground");
    var test_ground2 = platforms.create(game.world.width / 2.0, game.world.height - 256, "test_ground");

    /*  This loop sets up the platforms. It both sets them to immovable and makes them scroll   */
    for (i; i < platforms.children.length; i++)
    {
        platforms.children[i].body.immovable = true;
        platforms.children[i].body.velocity.x = -platform_scrolling_speed;  // setting it's velocity here means it will just always move...
    }


    // player
    player = game.add.sprite(20, test_ground.y - test_ground.height - 48, "test_dude");
    game.physics.arcade.enable(player);
    player.body.gravity.y = 400;
    player.body.bounce.y = .1;
    player.body.collodeWorldBounds = true;  // although honestly the player should never move horizontally ANYway

    player.animations.add("run", [5, 6, 7, 8], 10, true);
    player.animations.play("run");


    // initialize variables for the lightning strike properly
    frame_rate = game.time.fps;
    num_frame_in_strike = 2 * frame_rate;


}
//<!--End of create()-->

//<!--This function is loaded every frame-->
function update()
{

    // collide the player with the platforms
    if (game.physics.arcade.collide(player, platforms))         // if they are colliding, the player will stand still and slide along with the platforms!
    {
        player.body.velocity.x = platform_scrolling_speed;
        player_can_jump = true;
    }
    else
    {
        player.body.velocity.x = 0;
        player_can_jump = false;
    }



    /*  We will have to do lots of input mouse detection...
     *  I already wrote a click class. I'm thinking there's a global variable called "current_click."
     *  Whenever there is mouseDown, current_click is initialized by the click's X, Y, and time of the click
     *  Whenever there is a release, current_click.endClick( upX, upY, upTime ) is called
     *      Then the click itself determines what type of click it was with click.classifyClick()
     *      and THEN we do whatever we should do whatever response we should do
     *
     *  Ok I did this already! -Fuller <3
     */

    if( game.input.activePointer.leftButton.isDown )        // if clicking
    {
        if( !current_click )       // if current_click === null
        {
            var time = game.time.now;
            var mouseX = game.input.mousePointer.x;
            var mouseY = game.input.mousePointer.y;
            current_click = new Click(mouseX, mouseY, time);
        }
        else                        // current click exists
        {
            if( game.time.now - current_click.startT >= 500 )
            {
                // start doing charge animation for the player to use a bomb
                console.log("charging bomb...");
            }
        }
    }
    else
    {
        if( current_click )     // if current_click !== null
        {
            var time = game.time.now;
            var mouseX = game.input.mousePointer.x;
            var mouseY = game.input.mousePointer.y;
            current_click.endClick(mouseX, mouseY, time);

            // now do all the proper testing
            if ( current_click.type === "tap" )
            {
                if( player_can_jump )
                {
                    player.body.velocity.y = -400;  // arbitrary number. (but it is the same as what gravity is... For now, it's the height the player jumps to hit the next platform)
                    // we could also set "player_can_jump" back to false here, but it should already be taken care of
                }
            }
            else if ( current_click.type === "swipe right" )
            {
                // cooldown test
            }
            else if ( current_click.type === "swipe left" )
            {
                // cooldown test
            }
            else if ( current_click.type === "swipe up")
            {
                // cooldown test
            }
            else if (current_click.type === "swipe down")
            {
                // cooldown test
                console.log("Casting lightning!");
                new LightningSpell(current_click, .2);
            }
            else if (current_click.type === "hold")
            {
                // cooldown/availability test
            }

            // allow the player to be able to click again after we do the proper response to the player's click
            current_click = null;   //
        }
    }



    // play all the current animations
    var i = 0;
    while( i < lightningSpells.length )
    {
        var temp = lightningSpells[i];//lightningSpells[i].Play();
        temp.Play();
        i++;
    }

}
//<!--End of update()-->

/*
function castLightning( click )
{
    if( !initialized )
    {
        lightning_s_x = click.startX;
        lightning_s_y = click.startY;
        lightning_e_x = click.endX;
        lightning_e_y = click.endY;
        initialized = true;
    }

    if ( initialized )
    {
        console.log(lightning_s_x);
        if(animation_counter % 10 == 0)         // multiple times in the update step!
        {
            console.log(lightning_s_x);
            var offset_x = (animation_counter / num_frames_in_strike)  *  (lightning_e_x - lightning_s_x);
            var offset_y = (animation_counter / num_frames_in_strike) * (lightning_e_y - lightning_s_y);
            var fire = game.add.sprite(lightning_s_x + offset_x, lightning_s_y + offset_y, "fire1");
        }
    }


    animation_counter++;
    console.log(animation_counter);
    if(animation_counter > num_frames_in_strike)
    {
        lightning_s_x = lightning_s_y = lightning_e_x = lightning_e_y = null;
        initialized = false;
    }



}*/



    </script>

</body>
</html>