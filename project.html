<!doctype html>
<html>

<head>
    <title>Enter Game Name Here</title>
    <!--Phaser library version: 2.6.2-->
    <script src="lib/phaser.min.js"></script>
</head>

<body>


    <script type="text/javascript">
//<!--Game code goes here-->

// load before the game
function preload()
{
    game.load.spritesheet("test_dude", "assets/placeholder/dude.png", 32, 48);
    game.load.image("test_ground", "assets/placeholder/ground.png");
    game.load.image("fire1", "assets/placeholder/fire1.png");
    game.load.image("fire2", "assets/placeholder/fire2.png");
    game.load.image("fire3", "assets/placeholder/fire3.png");

}

// Click class
var Click = function (startX, startY, startT) {
    this.startX = startX;
    this.startY = startY;
    this.startT = startT;

    // initialize variables that will be used later
    this.endX = -1;
    this.endY = -1;
    this.endT = -1;
    this.type = null;
};

Click.prototype.endClick = function (upX, upY, upTime) {
    this.endX = upX;
    this.endY = upY;
    this.endT = upTime;
    this.classifyClick();    // determines what type of click it is
};

Click.prototype.classifyClick = function () {
    if( this.endX === -1 || this.endY === -1 || this.endT === -1 )     // for safety
    {
        console.log("In the middle of a click...");
    }

    var diffX = this.endX - this.startX;
    var diffY = this.endY - this.startY;
    var distance_traveled = Math.sqrt((diffX) * (diffX) + (diffY) * (diffY));

    // now, to start classifying the click type
    if ( (this.endT - this.startT) <= 250 && distance_traveled <= 50 )      // DETECT TAP
    {
        this.type = "tap";
        console.log("Tap!");
    }
    else if( (this.endT - this.startT) >= 1000 )                            // DETECT HOLD
    {
        this.type = "hold";
        console.log("Hold!");
    }
    else if( distance_traveled >= 50 )                                      // DETECT SWIPE
    {
        /* Distinguisges between swipes in each of the 4 directions */
        var abs_diffX = diffX;
        if (abs_diffX < 0) abs_diffX *= -1;
        var abs_diffY = diffY;
        if (abs_diffY < 0) abs_diffY *= -1;
        var slope = abs_diffY / abs_diffX;      // the ratio between the difference in X and the difference in Y

        if( slope > 1 || diffX === 0 )          // vertical swipe
        {
            if( diffY > 0 )
            {
                this.type = "swipe down";
                console.log("Swipe down!");
            }
            else
            {
                this.type = "swipe up";
                console.log("Swipe up!");
            }
        }
        else if( slope < 1 || diffY === 0 )     // horizontal swipe
        {
            if ( diffX > 0 )
            {
                this.type = "swipe right";
                console.log("Swipe right!");
            }
            else
            {
                this.type = "swipe left";
                console.log("Swipe left!");
            }
        }
        else
        {
            console.log("Wow... The Chosen Swipe");
        }
    }
    else
    {
        console.log("Wow that was a really shitty click if I do say so myself.");
    }
};


var LightningSpell = function( click, strike_time ) {
    this._click = click;
    this._duration = strike_time;          // in seconds
    this._frame_rate = game.time.fps;   // at time of creation
    this._num_anim_frames = strike_time * game.time.fps;
    this._animation_counter = 0;
    this._sprites_used = game.add.group();            // to clean up after the sprite is complete

    lightningSpells.push(this);
};

LightningSpell.prototype.Play = function () {
    if (this._animation_counter % 1 == 0)
    {
        var fire_type = Math.floor(Math.random() * (4 - 1)) + 1;    // pick a random fire sprite
        var completion_ratio = this._animation_counter / this._num_anim_frames;
        var offset_x = (1.0 * this._animation_counter / this._num_anim_frames) * (this._click.endX - this._click.startX);
        var offset_y = (1.0 * this._animation_counter / this._num_anim_frames) * (this._click.endY - this._click.startY);
        this._sprites_used.create(this._click.startX + offset_x - 64, this._click.startY + offset_y - 64, "fire" + fire_type.toString());
    }
    this._animation_counter++;

    if(this._animation_counter > this._num_anim_frames)
    {
        this.Finish();
    }
};

LightningSpell.prototype.Finish = function () {
    this._sprites_used.destroy();
    lightningSpells.shift();        // remove self from the lightningSpells global variable
    delete this;
};

var current_click = null;       // this is the player's current click. is null when not clicking

var game = new Phaser.Game(1334, 750, Phaser.AUTO, "[INSERT GAME NAME HERE]", { preload: preload, create: create, update: update});
var player;
var platforms;

var platform_scrolling_speed = 300;
var player_can_jump = false;

var lightningSpells = [];



// upon creation of the game
function create()
{
    var i = 0; // this is the loop counter;
    game.physics.startSystem(Phaser.Physics.ARCADE);

    game.input.mouse.capture = true;    // track the mouse
    game.time.advancedTiming = true;    // allow an fps counter without my having to make one

    platforms = game.add.group();
    platforms.enableBody = true;

    var test_ground = platforms.create(0, game.world.height - 64, "test_ground");
    var test_ground2 = platforms.create(game.world.width / 2.0, game.world.height - 256, "test_ground");

    /*  This loop sets up the platforms. It both sets them to immovable and makes them scroll   */
    for (i; i < platforms.children.length; i++)
    {
        platforms.children[i].body.immovable = true;
        platforms.children[i].body.velocity.x = -platform_scrolling_speed;  // setting it's velocity here means it will just always move...
    }


    // player
    player = game.add.sprite(20, test_ground.y - test_ground.height - 48, "test_dude");
    game.physics.arcade.enable(player);
    player.body.gravity.y = 400;
    player.body.bounce.y = .1;
    player.body.collodeWorldBounds = true;  // although honestly the player should never move horizontally ANYway

    player.animations.add("run", [5, 6, 7, 8], 10, true);
    player.animations.play("run");


    // initialize variables for the lightning strike properly
    frame_rate = game.time.fps;
    num_frame_in_strike = 2 * frame_rate;


}

function update()
{
    //<!--This function is loaded every frame-->

    // collide the player with the platforms
    if (game.physics.arcade.collide(player, platforms))         // if they are colliding, the player will stand still and slide along with the platforms!
    {
        player.body.velocity.x = platform_scrolling_speed;
        player_can_jump = true;
    }
    else
    {
        player.body.velocity.x = 0;
        player_can_jump = false;
    }



    /*  We will have to do lots of input mouse detection...
     *  I already wrote a click class. I'm thinking there's a global variable called "current_click."
     *  Whenever there is mouseDown, current_click is initialized by the click's X, Y, and time of the click
     *  Whenever there is a release, current_click.endClick( upX, upY, upTime ) is called
     *      Then the click itself determines what type of click it was with click.classifyClick()
     *      and THEN we do whatever we should do whatever response we should do
     *
     *  Ok I did this already! -Fuller <3
     */

    if( game.input.activePointer.leftButton.isDown )        // if clicking
    {
        if( !current_click )       // if current_click === null
        {
            var time = game.time.now;
            var mouseX = game.input.mousePointer.x;
            var mouseY = game.input.mousePointer.y;
            current_click = new Click(mouseX, mouseY, time);
        }
        else                        // current click exists
        {
            if( game.time.now - current_click.startT >= 500 )
            {
                // start doing charge animation for the player to use a bomb
                console.log("charging bomb...");
            }
        }
    }
    else
    {
        if( current_click )     // if current_click !== null
        {
            var time = game.time.now;
            var mouseX = game.input.mousePointer.x;
            var mouseY = game.input.mousePointer.y;
            current_click.endClick(mouseX, mouseY, time);

            // now do all the proper testing
            if ( current_click.type === "tap" )
            {
                if( player_can_jump )
                {
                    player.body.velocity.y = -400;  // arbitrary number. (but it is the same as what gravity is... For now, it's the height the player jumps to hit the next platform)
                    // we could also set "player_can_jump" back to false here, but it should already be taken care of
                }
            }
            else if ( current_click.type === "swipe right" )
            {
                // cooldown test
            }
            else if ( current_click.type === "swipe left" )
            {
                // cooldown test
            }
            else if ( current_click.type === "swipe up")
            {
                // cooldown test
            }
            else if (current_click.type === "swipe down")
            {
                // cooldown test
                console.log("Casting lightning!");
                new LightningSpell(current_click, .2);
            }
            else if (current_click.type === "hold")
            {
                // cooldown/availability test
            }

            // allow the player to be able to click again after we do the proper response to the player's click
            current_click = null;   //
        }
    }



    // play all the current animations
    var i = 0;
    while( i < lightningSpells.length )
    {
        var temp = lightningSpells[i];//lightningSpells[i].Play();
        temp.Play();
        i++;
    }


}

/*
function castLightning( click )
{
    if( !initialized )
    {
        lightning_s_x = click.startX;
        lightning_s_y = click.startY;
        lightning_e_x = click.endX;
        lightning_e_y = click.endY;
        initialized = true;
    }

    if ( initialized )
    {
        console.log(lightning_s_x);
        if(animation_counter % 10 == 0)         // multiple times in the update step!
        {
            console.log(lightning_s_x);
            var offset_x = (animation_counter / num_frames_in_strike)  *  (lightning_e_x - lightning_s_x);
            var offset_y = (animation_counter / num_frames_in_strike) * (lightning_e_y - lightning_s_y);
            var fire = game.add.sprite(lightning_s_x + offset_x, lightning_s_y + offset_y, "fire1");
        }
    }


    animation_counter++;
    console.log(animation_counter);
    if(animation_counter > num_frames_in_strike)
    {
        lightning_s_x = lightning_s_y = lightning_e_x = lightning_e_y = null;
        initialized = false;
    }



}*/



    </script>

</body>
</html>